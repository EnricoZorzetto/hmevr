% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hbev_module.R
\name{load_synth_data}
\alias{load_synth_data}
\title{Generate syntetic data according to a given specification.
  generates a matrix xij of synthetic data with dimension S*Nt
  where S = number of blocks (e.g., years), and
        Nt = number of observations/block
  with nj the number of non-zero events in each block
  Data are i.i.d., and non-zero events are stacked at the 'beginning' of each
  block (e.g., their random inter-arrival times are not reproduced here!)
  The distribution for the xij magnitudes and number of events nj
  must be specified from the possible available.}
\usage{
load_synth_data(S, ptrue, ntrue, Nt = 366, ndist = "betabin", dist = "gam")
}
\arguments{
\item{S}{length of the time series to be generated (in years / blocks)}

\item{ptrue}{list of parameters describing the distribution of event magnitudes}

\item{ntrue}{list of parameters describing the distribution of the number of events/block}

\item{Nt}{the length of each block (default Nt = 366)}

\item{ndist}{distribution of the number of events/block
(default is ndist='betabin' for the betabinomial distribution)}

\item{dist}{distribution of the event magnitudes
(default is dist='gam' for the gamma distribution)}
}
\value{

}
\description{
----------------------------------------------------------------------------
     'bin'      -> nj ~ binomial(Nt, pn)
     'betabin'  -> nj ~ betabinomial(Nt, an, bn) or [mn, varn]
     'constant' -> nj ~ diracDelta(nc)
 -----------------------------------------------------------------------------
}
\details{
The magnitudes of the events xij are drawn from one of the following models::
 -----------------------------------------------------------------------------
     Model specification:                         | Parameters to pass:
 -----------------------------------------------------------------------------
     'gam'     -> xij ~ gamma(a, b)               |  [a, b]
     'gpd'     -> xij ~ gpd(xi, sigma)            |  [xi, sigma]
     'wei'     -> xij ~ Weibull(C, w)             |  [C, w]
     'wei_dyl' -> xij ~ Weibull(Cj, wj) with      |  [muc, sigmac, muw, sigmaw]
                                                  |  or:   [mc, sc, mw, sw]
                  Cj  ~ lognormal(muc, sigmac)    |
                  wj  ~ lognormal(muw, sigmaw)    |
     'wei_dsl' -> xij ~ Weibull(Cj, w) with       |  [muc, sigmac, w]
                  Cj  ~ lognormal(muc, sigmac)    |
     'wei_dyn' -> xij ~ Weibull(Cj, wj) with      |  [ac, bc, aw, bw]
                                                  |  or: [mc, sc, mw, sw]
                   Cj   ~ gamma(ac, bc)           |
                   wj   ~ gamma(aw, bw)           |
     'gam_dyn' ->  xij ~ gamma(aj, bj) with       |  [aga, bga, agb, bgb]
                                                  |  or: [ma, sa, mb, sb]
                   aj  ~ gamma(aga, bga)          |
                   bj  ~ gamma(agb, bgb)          |
     'gan_dsc' ->  xij ~ gamma(a, bj) with        |  [a, agb, bgb]
                   bj   ~ gamma(agb, bgb)         |
 -----------------------------------------------------------------------------

 NB: for n~betabinomial, I can pass one of the following:
 ntrue = list(an=, bn=), or ntrue = list(mn=, varn=)
 i.e., mean and variance prescribed instead of the beta-binomial parameters.

 NB: for Ptrue, If *-> you can pass vector of means and stdvs instead
 as follows: list(ma=, sa=, mb=, sb=) or list(mc=, sc=, mw=, sw=)


  ptrue and ntrue must be named lists
  with parameter names as mentioned above for each distribution
  e.g., pass ptrue = list(pn = 0.4) in case of a binomial distr.
  ptrue = list(muw = 0, muc = 2, sigmac = 0.05, sigmaw = 0.05)
  in case of 'wei_dyl' distribution.

  Returns a named list containing::
  data   = the matrix with the data, of size S*Nt
  N      = array with number of events / block (length S)
  maxima = array of block maxima (of length S)
  Xi     = sorted annual maxima (length S)
  Fi     = non exceedance frequency of the Xi (length S)
  Tr     = empirical return time of the Xi (length S)
 ------------------------------------------------------------
}
